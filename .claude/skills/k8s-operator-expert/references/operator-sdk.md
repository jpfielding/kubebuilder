# Operator SDK Alternative

While Kubebuilder is the preferred tool, Operator SDK provides additional features and may be more suitable for certain use cases. Both tools use the same underlying controller-runtime library.

## When to Use Operator SDK

- **Helm-based operators**: Wrapping existing Helm charts as operators
- **Ansible-based operators**: Using Ansible playbooks for reconciliation
- **Go-based operators**: Similar to Kubebuilder but with additional CLI features
- **OLM integration**: Building operators for Operator Lifecycle Manager from the start
- **Scorecard testing**: Built-in operator quality and best practice checks

## Installation

```bash
# macOS
brew install operator-sdk

# Linux
export ARCH=$(case $(uname -m) in x86_64) echo -n amd64 ;; aarch64) echo -n arm64 ;; *) echo -n $(uname -m) ;; esac)
export OS=$(uname | awk '{print tolower($0)}')
export OPERATOR_SDK_DL_URL=https://github.com/operator-framework/operator-sdk/releases/download/v1.34.1
curl -LO ${OPERATOR_SDK_DL_URL}/operator-sdk_${OS}_${ARCH}
chmod +x operator-sdk_${OS}_${ARCH} && sudo mv operator-sdk_${OS}_${ARCH} /usr/local/bin/operator-sdk
```

## Go-Based Operators (Similar to Kubebuilder)

### Initialize Project

```bash
# Create new operator
operator-sdk init --domain example.com --repo github.com/myorg/my-operator

# Create API
operator-sdk create api --group apps --version v1 --kind MyResource --resource --controller
```

### Key Differences from Kubebuilder

1. **Additional CLI commands**
   ```bash
   # Generate bundle for OLM
   operator-sdk generate bundle

   # Run with OLM
   operator-sdk run bundle

   # Scorecard testing
   operator-sdk scorecard
   ```

2. **OLM manifests generated by default**
   - `bundle/` directory for OLM packaging
   - ClusterServiceVersion (CSV) definitions
   - Package manifests

3. **Makefile differences**
   - Additional targets for bundling
   - Scorecard integration
   - OLM-specific commands

### Migration from Kubebuilder

Most Kubebuilder operators can use Operator SDK with minimal changes:

```bash
# In existing Kubebuilder project
operator-sdk generate bundle --version 0.0.1
```

## Helm-Based Operators

Create operators that wrap existing Helm charts:

```bash
# Initialize Helm operator
operator-sdk init --plugins helm --domain example.com

# Create API from existing chart
operator-sdk create api --helm-chart=mychart --helm-chart-repo=https://charts.example.com

# Or from local chart
operator-sdk create api --helm-chart=./mychart
```

### How It Works

- Operator watches custom resources
- Reconciles by installing/upgrading Helm releases
- Maps CR spec to Helm values
- No Go code required

### Example CR

```yaml
apiVersion: apps.example.com/v1alpha1
kind: MyApp
metadata:
  name: myapp-sample
spec:
  # These values are passed to Helm chart
  replicaCount: 3
  image:
    repository: nginx
    tag: "1.21"
```

### Customization

Override default behavior in `watches.yaml`:

```yaml
- group: apps.example.com
  version: v1alpha1
  kind: MyApp
  chart: helm-charts/myapp
  overrideValues:
    # Static overrides
    service.type: ClusterIP
  reconcilePeriod: 5m
  watchDependentResources: true
```

## Ansible-Based Operators

Use Ansible playbooks for reconciliation:

```bash
# Initialize Ansible operator
operator-sdk init --plugins ansible --domain example.com

# Create API with Ansible role
operator-sdk create api --group apps --version v1 --kind MyResource --generate-role
```

### How It Works

- Operator watches custom resources
- Runs Ansible playbooks on reconciliation
- CR spec available as variables in playbooks
- No Go code required

### Example Playbook

In `roles/myresource/tasks/main.yml`:

```yaml
---
- name: Create Deployment
  kubernetes.core.k8s:
    definition:
      apiVersion: apps/v1
      kind: Deployment
      metadata:
        name: "{{ ansible_operator_meta.name }}-deployment"
        namespace: "{{ ansible_operator_meta.namespace }}"
      spec:
        replicas: "{{ replicas }}"
        selector:
          matchLabels:
            app: "{{ ansible_operator_meta.name }}"
        template:
          metadata:
            labels:
              app: "{{ ansible_operator_meta.name }}"
          spec:
            containers:
            - name: app
              image: "{{ image }}"
```

### Watches Configuration

In `watches.yaml`:

```yaml
---
- version: v1
  group: apps.example.com
  kind: MyResource
  role: myresource
  reconcilePeriod: 30s
  manageStatus: true
```

## OLM Integration

Operator SDK has first-class support for Operator Lifecycle Manager.

### Generate Bundle

```bash
# Generate OLM bundle
operator-sdk generate bundle --version 0.1.0

# Validate bundle
operator-sdk bundle validate ./bundle
```

### ClusterServiceVersion

Edit `bundle/manifests/*.clusterserviceversion.yaml`:

```yaml
apiVersion: operators.coreos.com/v1alpha1
kind: ClusterServiceVersion
metadata:
  name: my-operator.v0.1.0
spec:
  displayName: My Operator
  description: Manages MyResource instances
  version: 0.1.0
  install:
    strategy: deployment
    spec:
      deployments:
      - name: my-operator-controller-manager
        spec:
          # ... deployment spec
  customresourcedefinitions:
    owned:
    - name: myresources.apps.example.com
      version: v1
      kind: MyResource
      displayName: My Resource
```

### Testing with OLM

```bash
# Build and push bundle image
make bundle-build bundle-push IMG=<registry>/my-operator-bundle:v0.1.0

# Run with OLM
operator-sdk run bundle <registry>/my-operator-bundle:v0.1.0

# Cleanup
operator-sdk cleanup my-operator
```

## Scorecard

Built-in testing for operator best practices:

```bash
# Run scorecard tests
operator-sdk scorecard bundle

# Custom test configuration
operator-sdk scorecard bundle --config .scorecard.yaml
```

### Example Scorecard Configuration

```yaml
apiVersion: scorecard.operatorframework.io/v1alpha3
kind: Configuration
metadata:
  name: config
stages:
- parallel: true
  tests:
  - image: quay.io/operator-framework/scorecard-test:latest
    entrypoint:
    - scorecard-test
    - basic-check-spec
    labels:
      suite: basic
      test: basic-check-spec-test
```

## Choosing Between Kubebuilder and Operator SDK

### Use Kubebuilder when:
- Building pure Go operators
- Want minimal tooling and dependencies
- Don't need OLM integration immediately
- Prefer simpler project structure

### Use Operator SDK when:
- Wrapping Helm charts
- Using Ansible for automation
- Publishing to OperatorHub
- Need OLM integration from start
- Want scorecard testing

### Both Are Compatible
- Same underlying controller-runtime
- Can migrate between them
- Most patterns apply to both
- Community support for both

## Converting Helm/Ansible to Go

Start with Helm/Ansible for quick prototyping, convert to Go for more control:

1. Build Helm/Ansible operator first
2. Understand the reconciliation logic
3. Re-implement in Go using Kubebuilder/Operator SDK
4. Gain full control over reconciliation

## Additional Resources

- [Operator SDK Documentation](https://sdk.operatorframework.io/)
- [OLM Documentation](https://olm.operatorframework.io/)
- [OperatorHub.io](https://operatorhub.io/) - Public operator registry
- [Operator Capability Levels](https://sdk.operatorframework.io/docs/overview/operator-capabilities/)
